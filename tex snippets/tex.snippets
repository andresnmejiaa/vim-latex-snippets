# This file contains snippets for typesetting LaTeX
#
# Main references:
#	castel.dev
#	Hotschke vim post (for math-aware ultisnips) https://vi.stackexchange.com/a/18494/


priority 10

global !p

import re

# Checks if a string is a backslash. Used in snippets where you want to expand after a backslash
def isbackslash(string):
    if string == '\\':
	    return ''
    return string

# Functions for adding optional superscripts for sums, products, etc.
def superscriptstart(t):
	if t:
		return '^{'
	return ''
def superscriptend(t):
	if t:
		return '}'
	return ''

def greeklet(string):
	# List of lowercase Roman letters and the associated mappings to Greek letters
	# Obtained from the mapping of the standard Greek alphabet keyboard
	greekAlphabet = [['a','alpha'],['b','beta'],['c','xi'],['d','delta'],['e','epsilon'],['f','phi'],['g','gamma'],['h','eta'],['i','iota'],['k','kappa'],['l','lambda'],['m','mu'],['n','nu'],['o','omega'],['p','pi'],['q','theta'],['r','rho'],['s','sigma'],['t','tau'],['u','upsilon'],['v','omega'],['w','omega'],['x','chi'],['y','psi'],['z','zeta']]
	romanAlphabet = [j[0] for j in greekAlphabet]
	if string.lower() in romanAlphabet:
		roman_index = romanAlphabet.index(string.lower())
		greek_letter = greekAlphabet[roman_index][1]
		if string.isupper():
			return greek_letter.capitalize()
		else:
			return greek_letter
	else:
		return 'ERR'

endglobal


global !p
texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'V', 'W', 'X', 'Y', 'Z']]
# If you have http://www.drchip.org/astronaut/vim/vbafiles/amsmath.vba.gz,
# you want to add:
texMathZones += ['texMathZone'+x for x in ['E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS']]
texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

def isMath():
    synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
    if not set(texIgnoreMathZoneIds).isdisjoint(synstackids):
        return False
    return not set(texMathZoneIds).isdisjoint(synstackids)
    # isdisjoint() can short-circuit as soon as a match is found

def prose():
	return not isMath()

endglobal

##############################################

# Custom #

##############################################

#############
#### Math
#############

context "isMath()"
snippet '`([a-zA-Z])' "auto greek letter" rA
\\`!p snip.rv = greeklet(match.group(1))`$0
endsnippet

# Automatic math environment with post-fix (courtesy of castel.dev)
snippet mk "Math" wA
\$${1}\$`!p
if t[0] and t[0][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`${0}
endsnippet

context "isMath()"
snippet ,, "ldots" iA
, \\ldots, $0
endsnippet

context "isMath()"
snippet ++ "ldots plus" iA
+ \\ldots + $0
endsnippet

context "isMath()"
snippet :: "projective coordinates" iA
: \\ldots : $0
endsnippet

context "isMath()"
snippet ==  "equals" iA
&= $0
endsnippet

context "prose()"
snippet ii "item" bA
\\item $0
endsnippet

context "prose()"
snippet [[ "display math" bA
\\begin{align*}
	$1
\\end{align*}
$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=\$\/\(\)\{\}\[\]\\]|^):' "set condition" r
`!p snip.rv = isbackslash(match.group(1))`\\ : \\ $0
endsnippet

context "isMath()"
snippet * "dual" iA
^\\ast
endsnippet

context "isMath()"
snippet \{ "set" iA
\\left\\{ $1 \\right\\}$0
endsnippet

context "isMath()"
snippet >> ">>" iA
\\gg
endsnippet

context "isMath()"
snippet << "<<" iA
\\ll
endsnippet

snippet array "array"
\\begin{array}{$1} $2 \\end{array} $0
endsnippet

context "isMath()"
snippet "([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)([a-zA-Z])bar" "Automatic overline bar" riA
`!p snip.rv = isbackslash(match.group(1))`\\bar{`!p snip.rv=match.group(2)`}
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)bar' "overline bar environment" r
`!p snip.rv = isbackslash(match.group(1))`\\bar{$1}$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)bb([A-Z])' "math blackboard automatic" rA
`!p snip.rv = isbackslash(match.group(1))`\\mathbb{`!p snip.rv = match.group(2)`}$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)bbm([\d])' "math blackboard automatic" rA
`!p snip.rv = isbackslash(match.group(1))`\\mathbbm{`!p snip.rv = match.group(2)`}$0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)bcap' "Big cap environment" r
`!p snip.rv = isbackslash(match.group(1))`\\bigcap_{${1:n=1}}^{${2:\infty}} $0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)bcup' "Big cup environment" r
`!p snip.rv = isbackslash(match.group(1))`\\bigcup_{${1:n=1}}^{${2:\infty}} $0
endsnippet

context "prose()"
snippet '([\s\,\.\$\(\)\-]|^)bf' "bold" r
`!p snip.rv = match.group(1)`\\textbf{$1}$0
endsnippet

context "isMath()"
snippet '([\s\,\.\$\(\)\-]|^)bf' "bold" r
`!p snip.rv = match.group(1)`\\mathbf{$1}$0
endsnippet

context "isMath()"
snippet bmat "bmat" i
\\begin{bmatrix} $1 \\end{bmatrix} $0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)cal' "math cal" r
`!p snip.rv = isbackslash(match.group(1))`\\mathcal{${1:C}}$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)cal([A-Z])' "math cal automatic" rA
`!p snip.rv = isbackslash(match.group(1))`\\mathcal{`!p snip.rv = match.group(2)`}$0
endsnippet

context "isMath()"
snippet '([\s\d\",.\$\/\(\)\{\}\[\]\\]|^)cap' "\Cap environment" r
`!p snip.rv = isbackslash(match.group(1))`\\cap_{${1:n=1}}^{${2:\infty}} $0
endsnippet

context "isMath()"
snippet cd "cdots"
\\cdots $0
endsnippet

context "isMath()"
snippet ceil "ceiling" i
\\left\\lceil $1 \\right\\rceil $0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)cup' "\Cup environment" r
`!p snip.rv = isbackslash(match.group(1))`\\cup_{${1:n=1}}^{${2:\infty}} $0
endsnippet

snippet dm "Display Math" bwA
\\[
	$1
\\]
$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)es' "Empty set" r
`!p snip.rv = isbackslash(match.group(1))`\\emptyset$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)fk' "math frak" r
`!p snip.rv = isbackslash(match.group(1))`\\mathfrak{${1:C}}$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)fk([a-zA-Z])' "math frak automatic" rA
`!p snip.rv = isbackslash(match.group(1))`\\mathfrak{`!p snip.rv = match.group(2)`}$0
endsnippet

context "isMath()"
snippet floor "floor" i
\\left\\lfloor $1 \\right\\rfloor$0
endsnippet

snippet fnote "footnote" i
\\footnote{$1}$0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\(\)\{\}\[\]\\]|^)frac' "fraction" r
`!p snip.rv = isbackslash(match.group(1))`\\frac{$1}{$2}$0
endsnippet

context "isMath()"
snippet "([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)([a-zA-Z])hat" "Automatic hat" riA
`!p snip.rv = isbackslash(match.group(1))`\\hat{`!p snip.rv=match.group(2)`}
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)hat' "math hat environment" r
`!p snip.rv = isbackslash(match.group(1))`\\hat{$1}$0
endsnippet

context "isMath()"
snippet inf "infimum" w
\\inf_{${1:x\in X}} $0
endsnippet

context "isMath()"
snippet invs "inverse" iA
^{-1}
endsnippet

context "prose()"
snippet '([\s\,\.\$\(\)\-]|^)it' "italic" r
`!p snip.rv = match.group(1)`\\textit{$1}$0
endsnippet

context "isMath()"
snippet '([\s\,\.\$\(\)\-]|^)it' "italic" r
`!p snip.rv = match.group(1)`\\mathit{$1}$0
endsnippet
# TODO double check this is correct for LaTeX

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)l\(' "left parentheses" riA
`!p snip.rv = isbackslash(match.group(1))`\\left( $1 \\right)$0
endsnippet

context "isMath()"
snippet l[ "left sq bracket" iA
\\left[ $1 \\right]$0
endsnippet

context "isMath()"
snippet l| "left abs" iA
\\left| $1 \\right|$0
endsnippet

context "isMath()"
snippet ld "ldots"
\\ldots $0
endsnippet

context "isMath()"
snippet lim "limit" w
\\lim_{${1:n} \\to ${2:\\infty}}
endsnippet

context "isMath()"
snippet liminf "liminf" w
\\limsup_{${1:n} \\to ${2:\\infty}}
endsnippet

context "isMath()"
snippet limsup "limsup" w
\\limsup_{${1:n} \\to ${2:\\infty}}
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)lr' "lrangle" rA
`!p snip.rv = isbackslash(match.group(1))`\\left\\langle $1 \\right\\rangle$0
endsnippet

context "isMath()"
snippet nl "new line" A
\\\\
&${1:=} $0
endsnippet

context "isMath()"
snippet nsubgp "normal subgroup"
\\trianglelefteq
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)op' "oplus" r
`!p snip.rv = isbackslash(match.group(1))`\\oplus$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)op_' "oplus subscript" rA
`!p snip.rv = isbackslash(match.group(1))`\\oplus_{$1}$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)opp' "oplus plus.." rA
`!p snip.rv = isbackslash(match.group(1))`\\oplus \\ldots \\oplus$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)ot' "otimes" r
`!p snip.rv = isbackslash(match.group(1))`\\otimes$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)ot_' "otimes subscript" rA
`!p snip.rv = isbackslash(match.group(1))`\\otimes_{$1}$0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)ott' "otimes times.." rA
`!p snip.rv = isbackslash(match.group(1))`\\otimes \\cdots \\otimes$0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)ov' "overset" r
`!p snip.rv = isbackslash(match.group(1))`\\overset{${1:above}}{${2:below}}$0
endsnippet

context "isMath()"
snippet part "d/dx" w
\\frac{\\partial ${1:f}}{\\partial ${2:x}}$0
endsnippet

context "isMath()"
snippet pmat "Parentheses matrix" i
\\begin{pmatrix} $1 \\end{pmatrix} $0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)prod' "Product environment" wr
`!p snip.rv = isbackslash(match.group(1))`\\prod_{${1:n=1}}`!p snip.rv = superscriptstart(t[2])`${2:\\infty}`!p snip.rv = superscriptend(t[2])` $0
endsnippet

context "isMath()"
snippet qq "quad quad" A
\\quad\\quad $0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)res' "restriction" rA
`!p snip.rv = isbackslash(match.group(1))`\\left. $1 \\right|_{ $2 }$0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)sb' "subset" r
`!p snip.rv = isbackslash(match.group(1))`\\subseteq 
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)sbn' "subsetneq" r
`!p snip.rv = isbackslash(match.group(1))`\\subsetneq 
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)sc' "math script" r
`!p snip.rv = isbackslash(match.group(1))`\\mathscr{${1:C}}$0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)sc([A-Z])' "math script automatic" rA
`!p snip.rv = isbackslash(match.group(1))`\\mathscr{`!p snip.rv = match.group(2)`}$0
endsnippet

context "prose()"
snippet sec "section" b
\\section{$1}

$0
endsnippet

context "isMath()"
snippet SES "short exact sequence" i
0 \to ${1:A} \xto{${2:f}} ${3:B} \xto{${4:g}} ${5:C} \to 0${6:,}$0
endsnippet

context "prose()"
snippet subsec "subsection" bA
\\subsection{$1}

$0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\(\)\{\}\[\]\\]|^)sp' "supset" r
`!p snip.rv = isbackslash(match.group(1))`\\supseteq 
endsnippet

context "isMath()"
snippet '([\s\d,.\$\(\)\{\}\[\]\\]|^)spn' "supsetneq" r
`!p snip.rv = isbackslash(match.group(1))`\\supsetneq 
endsnippet

context "isMath()"
snippet '([\s\d,.\$\(\)\{\}\[\]\\]|^)sq' "Square Root" ir
`!p snip.rv = isbackslash(match.group(1))`\\sqrt{${1:${VISUAL}}}$0
endsnippet

context "isMath()"
snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)sum' "\Sum environment" r
`!p snip.rv = isbackslash(match.group(1))`\\sum_{${1:n=1}}`!p snip.rv = superscriptstart(t[2])`${2:\\infty}`!p snip.rv = superscriptend(t[2])` $0
endsnippet

context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)til' "overline tilde environment" r
`!p snip.rv = isbackslash(match.group(1))`\\widetilde{$1}$0
endsnippet

context "isMath()"
snippet vmat "Vertical Matrix" i
\\begin{vmatrix} $1 \\end{vmatrix} $0
endsnippet

################
### Tikz
################

snippet tikz2 "Tikz 2x2" b
\\[ \\begin{tikzcd}
	$1 & $2 \\\\
	$3 & $4
\\end{tikzcd} \\]
$0
endsnippet

snippet tikz3 "Tikz 3x3" b
\\[ \\begin{tikzcd}
	$1 & $2 & $3 \\\\
	$4 & $5 & $6 \\\\
	$7 & $8 & $9
\\end{tikzcd} \\]
$0
endsnippet

snippet tikzamp "tikz ampersand replacement"
\\begin{tikzcd}[ampersand replacement=\\&]
    $1 \\& $2 \\\\
    $3 \\& $4 \\\\
\\end{tikzcd} $0
endsnippet

snippet tdiag "tikz diagonal"
\\[ \\begin{tikzcd}[column sep=small]
    $1 & $2 & $3 \\\\
    $4 & $5 & $6 \\\\
    $7 & $8 & $9
\\end{tikzcd} \\]
$0
endsnippet

snippet tpic "Tikz picture environment" b
\\begin{figure}
	\\begin{tikzpicture}[h]
	$1
	\\end{tikzpicture}
	\\centering
\\end{figure}
$0
endsnippet

############
# Text Replacement
############

snippet Cech "Cech" A
\\v{C}ech
endsnippet

snippet etale "etale" A
\\'etale
endsnippet

snippet iff "if and only if"
if and only if
endsnippet

snippet inveritble "" A
invertible
endsnippet

snippet Kahler "Kahler" A
K\\"{a}hler
endsnippet




# vim:ft=snippets:
